<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Custom Form Builder - AppBuilder</title>
    <style>
      :root {
        --bg: #0f1720;
        --panel: #0b1220;
        --muted: #9aa4b2;
        --accent: #6ee7b7;
        --accent-2: #60a5fa;
        --card: linear-gradient(180deg, #071021, #0b1624);
        --glass: rgba(255, 255, 255, 0.03);
        --radius: 12px;
        --shadow: 0 6px 24px rgba(2, 6, 23, 0.6);
        font-synthesis: none;
      }

      * {
        box-sizing: border-box;
      }
      html,
      body {
        height: 100%;
      }
      body {
        margin: 0;
        font-family:
          Inter,
          system-ui,
          -apple-system,
          "Segoe UI",
          Roboto,
          "Helvetica Neue",
          Arial;
        background:
          radial-gradient(
            1200px 600px at 10% 10%,
            rgba(96, 165, 250, 0.06),
            transparent
          ),
          var(--bg);
        color: #e6eef7;
        padding: 28px;
      }

      .header {
        display: flex;
        align-items: center;
        gap: 16px;
        margin-bottom: 18px;
      }
      .header h1 {
        font-size: 20px;
        margin: 0;
        font-weight: 600;
      }
      .header p {
        margin: 0;
        color: var(--muted);
        font-size: 13px;
      }

      .container {
        display: flex;
        gap: 18px;
        align-items: flex-start;
      }
      .panel {
        background: var(--panel);
        border-radius: var(--radius);
        padding: 14px;
        box-shadow: var(--shadow);
        flex: 1;
      }
      .api-panel {
        max-width: 320px;
      }
      .pages-panel {
        max-width: 260px;
      }
      .preview-panel {
        max-width: 360px;
      }
      .form-panel {
        flex: 2;
        min-width: 420px;
      }

      h3 {
        margin: 0 0 10px 0;
        color: #dff6ee;
        font-size: 14px;
      }

      .api-item {
        background: var(--glass);
        padding: 10px;
        border-radius: 10px;
        margin: 8px 0;
        cursor: grab;
        border: 1px solid rgba(255, 255, 255, 0.03);
        display: flex;
        justify-content: space-between;
        align-items: center;
      }
      .api-item {
        position: relative;
      }
      .api-handle {
        width: 14px;
        height: 14px;
        border-radius: 50%;
        background: var(--accent-2);
        box-shadow: 0 4px 10px rgba(96, 165, 250, 0.12);
        margin-left: 8px;
        cursor: crosshair;
        flex: 0 0 auto;
      }
      .api-item.connecting {
        outline: 2px solid rgba(96, 165, 250, 0.18);
        transform: translateX(4px);
      }
      .api-item strong {
        font-size: 13px;
      }
      .api-item small {
        color: var(--muted);
        font-size: 12px;
      }
      .api-item.dragging {
        opacity: 0.5;
      }

      .form-canvas {
        min-height: 320px;
        border-radius: 10px;
        padding: 18px;
        background: linear-gradient(180deg, #06111b, #071423);
        border: 1px solid rgba(255, 255, 255, 0.02);
        overflow: auto;
        /* responsive max height: leave space for header & side panels */
        max-height: calc(100vh - 200px);
      }
      .form-canvas.full-page {
        padding: 12px;
        /* when showing a full page, allow taller canvas but still constrained */
        max-height: calc(100vh - 120px);
      }

      .form-element {
        background: linear-gradient(
          180deg,
          rgba(255, 255, 255, 0.02),
          transparent
        );
        border-radius: 8px;
        padding: 10px;
        margin: 10px 0;
        border: 1px solid rgba(255, 255, 255, 0.03);
      }

      .mapped {
        outline: 2px solid rgba(110, 231, 183, 0.12);
        box-shadow: 0 4px 14px rgba(16, 185, 129, 0.04);
      }

      /* Highlight submit candidates inside the canvas */
      .selectable-submit {
        outline: 2px dashed rgba(96, 165, 250, 0.22);
        border-radius: 6px;
        padding: 2px;
        transition:
          transform 0.12s,
          box-shadow 0.12s;
        cursor: pointer;
      }
      .selectable-submit:hover {
        transform: translateY(-3px);
        box-shadow: 0 8px 30px rgba(96, 165, 250, 0.08);
      }
      .selectable-submit.selected {
        outline: 3px solid rgba(110, 231, 183, 0.6);
        box-shadow: 0 12px 40px rgba(16, 185, 129, 0.08);
      }

      .mapping-preview {
        background: transparent;
        border: 1px dashed rgba(255, 255, 255, 0.03);
        padding: 10px;
        border-radius: 8px;
        color: var(--muted);
        font-family:
          ui-monospace, SFMono-Regular, Menlo, Monaco, "Courier New", monospace;
        font-size: 13px;
      }

      .btn {
        display: inline-flex;
        gap: 8px;
        align-items: center;
        justify-content: center;
        padding: 10px 12px;
        border-radius: 10px;
        border: none;
        background: linear-gradient(90deg, var(--accent), var(--accent-2));
        color: #042027;
        font-weight: 600;
        cursor: pointer;
      }
      .btn:hover {
        filter: brightness(0.98);
        transform: translateY(-1px);
      }
      .btn.ghost {
        background: transparent;
        border: 1px solid rgba(255, 255, 255, 0.04);
        color: var(--muted);
      }
      .btn.danger {
        background: linear-gradient(90deg, #fb7185, #f97316);
        color: white;
      }
      .btn.success {
        background: linear-gradient(90deg, #34d399, #10b981);
        color: #022;
      }

      .submit-buttons {
        margin-top: 12px;
      }
      .submit-button-option {
        background: transparent;
        border-radius: 8px;
        padding: 8px;
        border: 1px solid rgba(255, 255, 255, 0.02);
        margin: 6px 0;
        color: var(--muted);
        cursor: pointer;
      }

      /* Toast notifications */
      #toastContainer {
        position: fixed;
        right: 20px;
        top: 20px;
        z-index: 12000;
        display: flex;
        flex-direction: column;
        gap: 8px;
        pointer-events: none;
      }
      .toast {
        pointer-events: auto;
        min-width: 220px;
        max-width: 420px;
        background: rgba(2, 8, 23, 0.9);
        color: #e6eef7;
        padding: 10px 14px;
        border-radius: 10px;
        box-shadow: 0 8px 30px rgba(2, 6, 23, 0.6);
        display: flex;
        gap: 12px;
        align-items: center;
        font-size: 13px;
      }
      .toast.success {
        border-left: 4px solid #34d399;
      }
      .toast.error {
        border-left: 4px solid #fb7185;
      }
      .toast.info {
        border-left: 4px solid #60a5fa;
      }
      .toast .loader {
        width: 14px;
        height: 14px;
        border-radius: 50%;
        border: 2px solid rgba(255, 255, 255, 0.08);
        border-top-color: #fff;
        animation: spin 0.9s linear infinite;
      }
      @keyframes spin {
        to {
          transform: rotate(360deg);
        }
      }
      .submit-button-option.selected {
        background: rgba(96, 165, 250, 0.06);
        border-color: rgba(96, 165, 250, 0.12);
        color: #dff6ff;
      }

      .code-output {
        background: #04131a;
        color: #bfeaf1;
        padding: 12px;
        border-radius: 8px;
        font-family:
          ui-monospace, SFMono-Regular, Menlo, Monaco, "Courier New", monospace;
        white-space: pre-wrap;
        max-height: 320px;
        overflow: auto;
      }

      @media (max-width: 980px) {
        .container {
          flex-direction: column;
        }
        .api-panel,
        .pages-panel,
        .preview-panel {
          max-width: 100%;
        }
      }
    </style>
  </head>
  <body>
    <div class="header">
      <h1>Custom Form Builder</h1>
      <p>Drag API inputs to form elements and generate submission code</p>
    </div>

    <div class="container">
      <div class="panel pages-panel">
        <h3>Pages Using This API</h3>
        <div id="pagesList"></div>
        <div id="pageSelector" style="display: none">
          <h4>Select a Page:</h4>
          <select id="pageSelect" onchange="loadPageContent(this.value)">
            <option value="">Choose a page...</option>
          </select>
        </div>
      </div>

      <div class="panel api-panel">
        <h3>API Inputs</h3>
        <div id="apiInputs"></div>
        <div id="apiMethods" style="margin-top: 10px">
          <h4 style="margin: 6px 0 8px 0; color: var(--muted); font-size: 13px">
            API Methods
          </h4>
          <div id="apiMethodsList"></div>
        </div>
      </div>

      <div class="panel form-panel">
        <h3>Form Canvas</h3>
        <div class="form-canvas" id="formCanvas">
          <p style="color: #7f8c8d; text-align: center; margin-top: 180px">
            Paste your HTML form code here or drag form elements
          </p>
        </div>
        <div style="margin-top: 15px">
          <button class="btn" onclick="loadFormFromClipboard()">
            Load Form from Clipboard
          </button>
          <button class="btn" onclick="clearForm()">Clear Form</button>
          <button
            class="btn success"
            style="float: right"
            onclick="generateCode()"
          >
            Generate & Inject
          </button>
        </div>
      </div>

      <div class="panel preview-panel">
        <h3>Live Preview & Generate</h3>
        <div id="mappingPreview"></div>

        <!-- Toasts -->
        <div id="toastContainer" aria-live="polite"></div>

        <div style="margin-top: 12px">
          <h4>Preview Page</h4>
          <select
            id="previewSelect"
            style="
              width: 100%;
              padding: 8px;
              border-radius: 6px;
              border: 1px solid #ddd;
              margin-top: 6px;
            "
          >
            <option value="">Choose a page...</option>
          </select>
          <div style="display: flex; gap: 8px; margin-top: 8px">
            <button
              id="openPreviewBtn"
              class="btn"
              disabled
              onclick="openPreviewTab(document.getElementById('previewSelect').value)"
            >
              Open full preview
            </button>
          </div>
          <div
            id="injectStatus"
            style="margin-top: 8px; font-size: 12px; color: #2c3e50"
          ></div>
        </div>

        <div class="submit-buttons">
          <h4>Choose Submit Button:</h4>
          <div id="submitButtons"></div>
        </div>

        <div style="margin-top: 12px">
          <button
            class="btn success"
            onclick="injectMappings()"
            style="width: 100%"
          >
            Inject Mappings
          </button>
        </div>
      </div>
    </div>

    <script>
      let currentAPI = null;
      let mappings = {};
      let draggedElement = null;
      let selectedSubmitButton = null;

      // Global error handler for debugging
      window.addEventListener("error", function (e) {
        console.error("Form Builder Error:", e.error);
        console.error("Error details:", e);
      });

      window.addEventListener("unhandledrejection", function (e) {
        console.error("Form Builder Unhandled Rejection:", e.reason);
        console.error("Rejection details:", e);
        e.preventDefault(); // Prevent the default browser behavior
      });

      // Global validation function
      function validateSiteContext() {
        if (
          !window.currentSiteName ||
          typeof window.currentSiteName !== "string" ||
          window.currentSiteName.trim() === ""
        ) {
          console.error(
            "Site context validation failed: currentSiteName is invalid"
          );
          alert(
            "Form builder is not properly initialized. Please reopen from the admin panel."
          );
          return false;
        }
        return true;
      }

      // Initialize from sessionStorage or URL params
      window.onload = function () {
        try {
          const storedData = sessionStorage.getItem("formBuilderAPI");
          if (storedData) {
            console.log("Loading API data from sessionStorage");
            console.log("Raw stored data:", storedData);
            const data = JSON.parse(storedData);
            console.log("Parsed data:", data);

            // Validate the data structure
            if (!data.api || !data.method || !data.siteName) {
              throw new Error(
                "Invalid sessionStorage data structure: missing api, method, or siteName"
              );
            }

            // Validate siteName is not empty or undefined
            if (
              !data.siteName ||
              typeof data.siteName !== "string" ||
              data.siteName.trim() === ""
            ) {
              throw new Error("Invalid siteName in sessionStorage data");
            }

            // Store site name BEFORE calling loadAPI
            window.currentSiteName = data.siteName.trim();
            window.currentPage = data.page;
            loadAPI(data.api, data.method);
            // Try to immediately load the requested page into the canvas
            if (data.page) {
              loadPageContent(data.page)
                .then(() => {
                  try {
                    loadExistingMappings(data.page, data.api.name);
                  } catch (e) {}
                })
                .catch((err) => {
                  console.warn("Could not auto-load page from session:", err);
                });
            }
            // Clear the stored data
            sessionStorage.removeItem("formBuilderAPI");
          } else {
            // Try URL parameters as fallback
            const urlParams = new URLSearchParams(window.location.search);
            const apiName = urlParams.get("api");
            const method = urlParams.get("method");
            const siteName = urlParams.get("site");
            const pageName = urlParams.get("page");

            if (apiName && method && siteName) {
              console.log("Loading API data from URL parameters");
              // Validate siteName
              if (
                !siteName ||
                typeof siteName !== "string" ||
                siteName.trim() === ""
              ) {
                throw new Error("Invalid site name from URL parameters");
              }

              // Fetch API data from server
              fetch(`/api/sites/${encodeURIComponent(siteName.trim())}`)
                .then((response) => {
                  if (!response.ok) {
                    throw new Error(
                      `HTTP ${response.status}: ${response.statusText}`
                    );
                  }
                  return response.json();
                })
                .then((siteData) => {
                  const api = siteData.apis.find((a) => a.name === apiName);
                  if (api) {
                    // Set site name BEFORE calling loadAPI
                    window.currentSiteName = siteName.trim();
                    window.currentPage = pageName;
                    loadAPI(api, method);
                    // Attempt to load the requested page immediately
                    if (pageName) {
                      loadPageContent(pageName)
                        .then(() => {
                          try {
                            loadExistingMappings(pageName, api.name);
                          } catch (e) {}
                        })
                        .catch((err) => {
                          console.warn(
                            "Could not auto-load page from URL params:",
                            err
                          );
                        });
                    }
                  } else {
                    throw new Error("API not found in site data");
                  }
                })
                .catch((error) => {
                  console.error("Error loading API from URL:", error);
                  alert(`Error loading API data: ${error.message}`);
                });
            } else {
              console.warn(
                "No API data found in sessionStorage or URL parameters"
              );
              alert(
                "No API data found. Please open the form builder from the admin panel."
              );
            }
          }
        } catch (e) {
          console.error("Error in window.onload:", e);
          console.error("Error details:", e.stack);
          alert(`Error initializing form builder: ${e.message}`);
        }
      };
      function loadAPI(api, method) {
        currentAPI = {
          name: api.name,
          method: method,
          inputs: api.bodyTemplate || {},
        };
        displayAPIInputs();

        // Load pages for this API - displayPagesList will auto-load the first page if available
        loadPagesForAPI();
      }

      function loadExistingMappings(page, apiName) {
        if (!validateSiteContext()) return;

        console.log("Loading existing mappings for", page, apiName);
        fetch(
          `/api/sites/${encodeURIComponent(window.currentSiteName)}/pages/${encodeURIComponent(page)}/api/${encodeURIComponent(apiName)}/mapping`
        )
          .then((response) => {
            console.log("Mapping response status:", response.status);
            if (response.status === 404) {
              console.log("No existing mapping found");
              // No existing mapping, that's fine
              return null;
            }
            if (!response.ok) {
              throw new Error(
                `HTTP ${response.status}: ${response.statusText}`
              );
            }
            return response.json();
          })
          .then((mapping) => {
            console.log("Loaded mapping:", mapping);
            if (mapping && mapping.fieldMappings) {
              // Load existing field mappings
              Object.keys(mapping.fieldMappings).forEach((field) => {
                const selector = mapping.fieldMappings[field];
                console.log("Looking for element with selector:", selector);
                const element = document.querySelector(selector);
                console.log("Found element:", element);
                if (element) {
                  // Create mapping for this field directly
                  createMapping(field, element);
                  console.log("Created mapping for field:", field);
                } else {
                  console.log("Element not found for selector:", selector);
                }
              });

              // Set submit button if it exists
              if (mapping.submitSelector) {
                console.log(
                  "Setting submit button with selector:",
                  mapping.submitSelector
                );
                selectedSubmitButton = document.querySelector(
                  mapping.submitSelector
                );
                console.log("Selected submit button:", selectedSubmitButton);
              }

              // Update UI to reflect loaded mappings
              updateMappingPreview();
              updateSubmitButtons();
            }
          })
          .catch((error) => {
            console.error("Error loading existing mappings:", error);
            // Don't show alert for 404 errors as they're expected when no mappings exist
            if (!error.message.includes("404")) {
              alert(`Error loading existing mappings: ${error.message}`);
            }
          });
      }

      function loadPagesForAPI() {
        if (!currentAPI || !validateSiteContext()) {
          console.warn(
            "Cannot load pages: missing currentAPI or invalid site context"
          );
          return;
        }

        fetch(
          `/api/sites/${encodeURIComponent(window.currentSiteName)}/api/${encodeURIComponent(currentAPI.name)}/pages`
        )
          .then((response) => {
            if (!response.ok) {
              throw new Error(
                `HTTP ${response.status}: ${response.statusText}`
              );
            }
            return response.json();
          })
          .then((pages) => {
            displayPagesList(pages);
          })
          .catch((error) => {
            console.error("Error loading pages:", error);
            showPageSelector();
          });
      }

      function displayPagesList(pages) {
        const container = document.getElementById("pagesList");
        const selector = document.getElementById("pageSelector");
        const previewSelect = document.getElementById("previewSelect");

        if (pages && pages.length > 0) {
          container.innerHTML = "<h4>Pages with this API:</h4>";
          pages.forEach((page) => {
            const div = document.createElement("div");
            div.className = "api-item";
            if (page === window.currentPage) {
              div.className += " mapped"; // Highlight current page
              div.innerHTML = `<strong>${page}</strong> <small>(current)</small>`;
            } else {
              div.textContent = page;
            }
            div.onclick = () => loadPageContent(page);
            container.appendChild(div);
          });

          // Automatically load the first page if no current page is set
          if (!window.currentPage && pages.length > 0) {
            console.log("Auto-loading first page with mappings:", pages[0]);
            window.currentPage = pages[0];
            loadPageContent(pages[0]).then(() => {
              loadExistingMappings(pages[0], currentAPI.name);
            });
          }

          selector.style.display = "none";

          // populate preview select if present
          if (previewSelect) {
            previewSelect.innerHTML =
              '<option value="">Choose a page...</option>';
            pages.forEach((p) => {
              const o = document.createElement("option");
              o.value = p;
              o.textContent = p;
              if (p === window.currentPage) o.selected = true;
              previewSelect.appendChild(o);
            });
          }
        } else {
          container.innerHTML = "<p>No pages currently use this API.</p>";
          showPageSelector();
        }
      }

      function showPageSelector() {
        if (!validateSiteContext()) return;

        const selector = document.getElementById("pageSelector");
        const select = document.getElementById("pageSelect");
        const previewSelect = document.getElementById("previewSelect");

        // Load available pages
        fetch(`/api/sites/${encodeURIComponent(window.currentSiteName)}/pages`)
          .then((response) => {
            if (!response.ok) {
              throw new Error(
                `HTTP ${response.status}: ${response.statusText}`
              );
            }
            return response.json();
          })
          .then((pages) => {
            select.innerHTML = '<option value="">Choose a page...</option>';
            pages.forEach((page) => {
              const option = document.createElement("option");
              option.value = page;
              option.textContent = page;
              if (page === window.currentPage) {
                option.selected = true;
              }
              select.appendChild(option);
            });

            if (previewSelect) {
              previewSelect.innerHTML =
                '<option value="">Choose a page...</option>';
              pages.forEach((p) => {
                const o = document.createElement("option");
                o.value = p;
                o.textContent = p;
                if (p === window.currentPage) o.selected = true;
                previewSelect.appendChild(o);
              });
            }
          })
          .catch((error) => {
            console.error("Error loading available pages:", error);
            alert(`Error loading pages: ${error.message}`);
          });

        selector.style.display = "block";
      }

      function loadPageContent(pageName) {
        if (!pageName) return Promise.resolve();

        // Set the current page
        window.currentPage = pageName;

        if (!validateSiteContext()) {
          return Promise.reject(new Error("Invalid site context"));
        }

        return fetch(
          `/api/sites/${encodeURIComponent(window.currentSiteName)}/pages/${encodeURIComponent(pageName)}`
        )
          .then((response) => {
            if (!response.ok) {
              throw new Error(
                `HTTP ${response.status}: ${response.statusText}`
              );
            }
            return response.text();
          })
          .then((html) => {
            // Parse the HTML and extract the body content
            const parser = new DOMParser();
            const doc = parser.parseFromString(html, "text/html");
            const body = doc.body;

            if (body) {
              // Remove scripts and styles to avoid conflicts with form builder
              const scripts = body.querySelectorAll("script");
              const styles = body.querySelectorAll(
                'style, link[rel="stylesheet"]'
              );
              scripts.forEach((script) => script.remove());
              styles.forEach((style) => style.remove());

              // Ensure form inputs have stable ids for reliable selectors
              const inputs = body.querySelectorAll(
                "input, textarea, select, button"
              );
              inputs.forEach((el, idx) => {
                if (!el.id) {
                  el.id = `abgen_${Date.now().toString(36)}_${idx}`;
                }
              });

              // Load the entire body content
              formCanvas.innerHTML = body.innerHTML;
              formCanvas.classList.add("full-page");
              updateSubmitButtons();
              // adjust canvas height after loading page content
              try {
                adjustCanvasHeight();
              } catch (e) {}
              attachFormEvents();

              // Load existing mappings for this page and API
              loadExistingMappings(pageName, currentAPI.name);
            } else {
              throw new Error("No body content found in the selected page");
            }
          })
          .catch((error) => {
            console.error("Error loading page content:", error);
            alert(`Error loading page content: ${error.message}`);
          });
      }

      function displayAPIInputs() {
        const container = document.getElementById("apiInputs");
        container.innerHTML = "";

        if (!currentAPI || !currentAPI.inputs) return;

        Object.keys(currentAPI.inputs).forEach((field) => {
          const value = currentAPI.inputs[field];
          const div = document.createElement("div");
          div.className = "api-item";
          // API items are clickable nodes now (connector mode)
          div.dataset.field = field;
          div.dataset.value = value;

          div.innerHTML = `
                    <div style="display:flex;align-items:center;gap:8px;flex:1">
                      <div style="flex:1">
                        <strong>${field}</strong><br>
                        <small>Type: ${typeof value} | Value: ${String(value)}</small>
                      </div>
                      <div class="api-handle" title="Drag to connect" data-field="${field}"></div>
                    </div>
                `;
          // clicking item still starts connect mode
          div.addEventListener("click", (ev) => {
            // ignore clicks that originate from the handle
            if (
              ev.target &&
              ev.target.classList &&
              ev.target.classList.contains("api-handle")
            )
              return;
            startConnectMode(field, div, "field");
          });
          // handle mousedown on the small handle to start drag-connect
          div.querySelectorAll(".api-handle").forEach((h) => {
            h.addEventListener("mousedown", (ev) => {
              ev.stopPropagation();
              ev.preventDefault();
              startDragConnect(field, div, ev.clientX, ev.clientY);
            });
          });
          container.appendChild(div);
        });

        // Render methods list (allow connecting methods to submit buttons)
        const methodsContainer = document.getElementById("apiMethodsList");
        if (methodsContainer) {
          methodsContainer.innerHTML = "";
          const methods = currentAPI.methods || [currentAPI.method || "POST"];
          methods.forEach((m) => {
            const md = document.createElement("div");
            md.className = "api-item";
            md.style.marginTop = "6px";
            md.innerHTML = `
              <div style="display:flex;align-items:center;gap:8px;flex:1">
                <div style="flex:1">
                  <strong>${m}</strong> <br>
                  <small style="color:var(--muted)">/${currentAPI.name}</small>
                </div>
                <div class="api-handle" title="Drag to connect method" data-field="${m}" data-kind="method"></div>
              </div>
            `;
            md.addEventListener("click", () =>
              startConnectMode(m, md, "method")
            );
            // add drag-handle listener
            md.querySelectorAll(".api-handle").forEach((h) => {
              h.addEventListener("mousedown", (ev) => {
                ev.stopPropagation();
                ev.preventDefault();
                startDragConnect(m, md, ev.clientX, ev.clientY, "method");
              });
            });
            methodsContainer.appendChild(md);
          });
        }
      }

      // connector-mode variables and SVG overlay
      const formCanvas = document.getElementById("formCanvas");
      let connectingField = null;
      let connectingAPINode = null;
      let connectingKind = null; // 'field' or 'method'
      let connectingKey = null; // current key being connected (field name or method)
      const connections = {}; // field -> { element, selector, path }
      connections.methods = connections.methods || {}; // method -> { element, selector, path }

      function initConnectorOverlay() {
        // create an SVG overlay that sits on top of UI to draw arrows
        if (document.getElementById("connectorSvg")) return;
        const svg = document.createElementNS(
          "http://www.w3.org/2000/svg",
          "svg"
        );
        svg.id = "connectorSvg";
        svg.setAttribute(
          "style",
          "position:fixed;left:0;top:0;width:100%;height:100%;pointer-events:none;z-index:9999"
        );
        // add defs for arrowheads
        const defs = document.createElementNS(
          "http://www.w3.org/2000/svg",
          "defs"
        );
        const marker = document.createElementNS(
          "http://www.w3.org/2000/svg",
          "marker"
        );
        marker.setAttribute("id", "arrow-end");
        marker.setAttribute("markerWidth", "8");
        marker.setAttribute("markerHeight", "8");
        marker.setAttribute("refX", "6");
        marker.setAttribute("refY", "4");
        marker.setAttribute("orient", "auto");
        const path = document.createElementNS(
          "http://www.w3.org/2000/svg",
          "path"
        );
        path.setAttribute("d", "M0,0 L8,4 L0,8 z");
        path.setAttribute("fill", "rgba(96,165,250,0.95)");
        marker.appendChild(path);
        defs.appendChild(marker);
        svg.appendChild(defs);
        document.body.appendChild(svg);
      }

      // Adjust form canvas height to fill available viewport space responsively
      function adjustCanvasHeight() {
        try {
          const canvas = document.getElementById("formCanvas");
          const header = document.querySelector(".header");
          if (!canvas) return;
          const headerBottom = header
            ? header.getBoundingClientRect().bottom
            : 80;
          // leave 24px bottom padding and 24px top padding
          const avail = Math.max(240, window.innerHeight - headerBottom - 48);
          canvas.style.maxHeight = avail + "px";
        } catch (e) {
          // ignore
        }
      }

      window.addEventListener("resize", adjustCanvasHeight);

      function startConnectMode(key, apiNode, kind) {
        if (!formCanvas) return;
        initConnectorOverlay();
        // set connecting state
        connectingKind = kind || "field";
        connectingKey = key;
        if (connectingKind === "field") connectingField = key;
        else if (connectingKind === "method") connectingField = null;
        connectingAPINode = apiNode;
        // visual cue
        document
          .querySelectorAll(".api-item")
          .forEach((n) => n.classList.remove("connecting"));
        apiNode.classList.add("connecting");
        // inform user
        const status = document.getElementById("injectStatus");
        if (status)
          status.textContent =
            connectingKind === "method"
              ? `Connecting: select a submit button for method "${key}"`
              : `Connecting: select a target element for "${key}"`;
      }

      // handle clicks inside the canvas to pick a target element
      formCanvas.addEventListener("click", function (e) {
        if (!connectingKind) return;
        if (connectingKind === "field") {
          // find closest form input/select/textarea/button element inside canvas
          const target = e.target.closest("input,textarea,select,button");
          if (!target || !formCanvas.contains(target)) {
            // clicking outside a valid element cancels
            cancelConnectMode();
            return;
          }
          // create mapping and draw arrow
          createMapping(connectingKey, target);
          drawConnection(connectingKey, connectingAPINode, target);
          cancelConnectMode();
        } else if (connectingKind === "method") {
          // method should be connected to a submit-like element
          const target = e.target.closest(
            'input[type="submit"],button[type="submit"],button:not([type]),input[type="button"],button[type="button"]'
          );
          if (!target || !formCanvas.contains(target)) {
            cancelConnectMode();
            return;
          }
          // store method mapping and auto-select the submit button
          connections.methods = connections.methods || {};
          connections.methods[connectingKey] = {
            element: target,
            selector: getElementSelector(target),
          };
          target.classList.add("mapped");
          // select this submit button in the UI
          try {
            selectSubmitButton(target);
            updateSubmitButtons();
          } catch (e) {}
          drawConnection(connectingKey, connectingAPINode, target);
          updateMappingPreview();
          cancelConnectMode();
        }
      });

      function cancelConnectMode() {
        connectingField = null;
        if (connectingAPINode) connectingAPINode.classList.remove("connecting");
        connectingAPINode = null;
        const status = document.getElementById("injectStatus");
        if (status) status.textContent = "";
      }

      function createMapping(field, target) {
        mappings[field] = {
          element: target,
          selector: getElementSelector(target),
        };

        target.classList.add("mapped");
        updateMappingPreview();
        updateSubmitButtons();
        // store connection
        connections[field] = connections[field] || {};
        connections[field].element = target;
        connections[field].selector = mappings[field].selector;
      }

      function drawConnection(field, apiNode, target) {
        try {
          initConnectorOverlay();
          const svg = document.getElementById("connectorSvg");
          // remove old path for this field
          if (connections[field] && connections[field].path) {
            try {
              connections[field].path.remove();
            } catch (e) {}
          }

          // prefer the small handle dot as the start point when present
          let aRect = null;
          try {
            const h =
              apiNode && apiNode.querySelector
                ? apiNode.querySelector(".api-handle")
                : null;
            aRect = h
              ? h.getBoundingClientRect()
              : apiNode.getBoundingClientRect();
          } catch (e) {
            aRect = apiNode.getBoundingClientRect();
          }
          const tRect = target.getBoundingClientRect();
          const startX = aRect.left + aRect.width / 2;
          const startY = aRect.top + aRect.height / 2;
          const endX = tRect.left + tRect.width / 2;
          const endY = tRect.top + tRect.height / 2;

          // create a smooth cubic bezier path
          const dx = Math.abs(endX - startX);
          const controlX1 = startX + dx * 0.25;
          const controlX2 = endX - dx * 0.25;
          const pathStr = `M ${startX} ${startY} C ${controlX1} ${startY} ${controlX2} ${endY} ${endX} ${endY}`;
          const path = document.createElementNS(
            "http://www.w3.org/2000/svg",
            "path"
          );
          path.setAttribute("d", pathStr);
          path.setAttribute("marker-end", "url(#arrow-end)");
          path.setAttribute("stroke", "rgba(96,165,250,0.9)");
          path.setAttribute("stroke-width", "3");
          path.setAttribute("fill", "none");
          path.setAttribute("data-field", field);
          path.style.filter = "drop-shadow(0 6px 18px rgba(2,6,23,0.6))";
          svg.appendChild(path);
          connections[field] = connections[field] || {};
          connections[field].path = path;
          // keep a reference to the api node so we can recompute path on scroll/resize
          try {
            connections[field].apiNode = apiNode;
          } catch (e) {}
        } catch (e) {
          console.error("drawConnection error", e);
        }
      }

      // Recompute an individual connection's SVG path
      function updateConnectionPath(field) {
        try {
          const conn = connections[field];
          if (!conn || !conn.path || !conn.element || !conn.apiNode) return;
          const apiNode = conn.apiNode;
          const target = conn.element;
          let aRect = null;
          try {
            const h =
              apiNode && apiNode.querySelector
                ? apiNode.querySelector(".api-handle")
                : null;
            aRect = h
              ? h.getBoundingClientRect()
              : apiNode.getBoundingClientRect();
          } catch (e) {
            aRect = apiNode.getBoundingClientRect();
          }
          const tRect = target.getBoundingClientRect();
          const startX = aRect.left + aRect.width / 2;
          const startY = aRect.top + aRect.height / 2;
          const endX = tRect.left + tRect.width / 2;
          const endY = tRect.top + tRect.height / 2;
          const dx = Math.abs(endX - startX);
          const controlX1 = startX + dx * 0.25;
          const controlX2 = endX - dx * 0.25;
          const pathStr = `M ${startX} ${startY} C ${controlX1} ${startY} ${controlX2} ${endY} ${endX} ${endY}`;
          conn.path.setAttribute("d", pathStr);
        } catch (e) {
          // ignore
        }
      }

      // Update all connections (throttled by rAF)
      let _connRaf = null;
      function updateAllConnections() {
        try {
          Object.keys(connections).forEach((f) => updateConnectionPath(f));
        } catch (e) {}
        _connRaf = null;
      }

      function scheduleConnectionsUpdate() {
        if (_connRaf) return;
        _connRaf = requestAnimationFrame(updateAllConnections);
      }

      // Keep connectors in sync when the page or canvas scrolls/resizes
      window.addEventListener("resize", scheduleConnectionsUpdate);
      window.addEventListener("scroll", scheduleConnectionsUpdate, true);
      if (formCanvas)
        formCanvas.addEventListener("scroll", scheduleConnectionsUpdate);

      // --- Drag-to-connect implementation for a smoother UX ---
      let _dragState = null; // { field, apiNode, tempPath }

      function startDragConnect(field, apiNode, startX, startY, kind) {
        initConnectorOverlay();
        const svg = document.getElementById("connectorSvg");
        if (!svg) return;
        // create a temp path
        const temp = document.createElementNS(
          "http://www.w3.org/2000/svg",
          "path"
        );
        temp.setAttribute("stroke", "rgba(96,165,250,0.85)");
        temp.setAttribute("stroke-width", "3");
        temp.setAttribute("fill", "none");
        temp.setAttribute("stroke-dasharray", "6 8");
        temp.setAttribute("marker-end", "url(#arrow-end)");
        svg.appendChild(temp);
        // save and disable text selection + set cursor while dragging
        const prevUserSelect = document.body.style.userSelect || "";
        const prevCursor = document.body.style.cursor || "";
        try {
          document.body.style.userSelect = "none";
          document.body.style.cursor = "crosshair";
        } catch (e) {}
        _dragState = {
          field: field,
          apiNode: apiNode,
          tempPath: temp,
          prevUserSelect,
          prevCursor,
        };

        function onMove(ev) {
          try {
            const x = ev.clientX;
            const y = ev.clientY;
            // prefer handle position for drag visuals
            let aRect = null;
            try {
              const h =
                apiNode && apiNode.querySelector
                  ? apiNode.querySelector(".api-handle")
                  : null;
              aRect = h
                ? h.getBoundingClientRect()
                : apiNode.getBoundingClientRect();
            } catch (e) {
              aRect = apiNode.getBoundingClientRect();
            }
            const sX = aRect.left + aRect.width / 2;
            const sY = aRect.top + aRect.height / 2;
            const dx = Math.abs(x - sX);
            const c1 = sX + dx * 0.25;
            const c2 = x - dx * 0.25;
            const d = `M ${sX} ${sY} C ${c1} ${sY} ${c2} ${y} ${x} ${y}`;
            temp.setAttribute("d", d);
            try {
              document.body.style.cursor = "grabbing";
            } catch (e) {}
          } catch (e) {}
        }

        function onUp(ev) {
          try {
            document.removeEventListener("mousemove", onMove);
            document.removeEventListener("mouseup", onUp);
            if (!_dragState) return;
            const x = ev.clientX;
            const y = ev.clientY;
            const el = document.elementFromPoint(x, y);
            let target = el ? el.closest("input,textarea,select,button") : null;
            if (!target || !formCanvas.contains(target)) {
              try {
                _dragState.tempPath.remove();
              } catch (e) {}
              _dragState = null;
              scheduleConnectionsUpdate();
              return;
            }
            // finalize mapping (field vs method)
            if (kind === "method") {
              connections.methods = connections.methods || {};
              connections.methods[_dragState.field] = {
                element: target,
                selector: getElementSelector(target),
              };
              target.classList.add("mapped");
              // auto-select the button that was dropped onto
              try {
                selectSubmitButton(target);
                updateSubmitButtons();
              } catch (e) {}
              drawConnection(_dragState.field, _dragState.apiNode, target);
              updateMappingPreview();
            } else {
              createMapping(_dragState.field, target);
              drawConnection(_dragState.field, _dragState.apiNode, target);
            }
            try {
              _dragState.tempPath.remove();
            } catch (e) {}
            try {
              if (_dragState) {
                document.body.style.userSelect =
                  _dragState.prevUserSelect || "";
                document.body.style.cursor = _dragState.prevCursor || "";
              }
            } catch (ee) {}
            _dragState = null;
            scheduleConnectionsUpdate();
          } catch (e) {
            try {
              _dragState && _dragState.tempPath && _dragState.tempPath.remove();
            } catch (e) {}
            try {
              if (_dragState) {
                document.body.style.userSelect =
                  _dragState.prevUserSelect || "";
                document.body.style.cursor = _dragState.prevCursor || "";
              }
            } catch (ee) {}
            _dragState = null;
          }
        }

        document.addEventListener("mousemove", onMove);
        document.addEventListener("mouseup", onUp);
      }

      // --- Toast utilities ---
      function showToast(message, type = "info", opts = {}) {
        try {
          const container = document.getElementById("toastContainer");
          if (!container) return null;
          const t = document.createElement("div");
          t.className = "toast " + (type || "info");
          if (type === "loading") {
            const loader = document.createElement("div");
            loader.className = "loader";
            t.appendChild(loader);
          }
          const msg = document.createElement("div");
          msg.textContent = message;
          t.appendChild(msg);
          container.appendChild(t);
          const timeout = opts.timeout || (type === "loading" ? 0 : 3500);
          if (timeout > 0) setTimeout(() => t.remove(), timeout);
          return t;
        } catch (e) {
          return null;
        }
      }

      function dismissToast(el) {
        try {
          if (el && el.remove) el.remove();
        } catch (e) {}
      }

      function assembleInjectionScript() {
        try {
          const map = {};
          Object.keys(mappings).forEach((f) => (map[f] = mappings[f].selector));
          const methods = {};
          if (connections && connections.methods) {
            Object.keys(connections.methods).forEach((m) => {
              methods[m] = connections.methods[m].selector;
            });
          }
          const apiName = currentAPI && currentAPI.name ? currentAPI.name : "";
          const site = getCurrentSite();

          // Build script string safely
          let script = "(function(){\n";
          script += "var mappings = " + JSON.stringify(map) + ";\n";
          script += "var methods = " + JSON.stringify(methods) + ";\n";
          script += "var apiName = " + JSON.stringify(apiName) + ";\n";
          script += "var site = " + JSON.stringify(site) + ";\n";
          // small notify helper and override native alert inside injected script
          script +=
            "(function(){try{function __fb_notify(msg,type){try{var c=document.getElementById('__fb_toast_container');if(!c){c=document.createElement('div');c.id='__fb_toast_container';c.style.position='fixed';c.style.top='16px';c.style.right='16px';c.style.zIndex='9999999';c.style.display='flex';c.style.flexDirection='column';c.style.gap='8px';document.body.appendChild(c);}var t=document.createElement('div');t.textContent=msg;t.style.padding='8px 12px';t.style.borderRadius='8px';t.style.color='#fff';t.style.fontFamily='sans-serif';t.style.fontSize='13px';t.style.boxShadow='0 8px 24px rgba(0,0,0,0.18)';if(type==='success'){t.style.background='#16a34a';}else if(type==='error'){t.style.background='#ef4444';}else{t.style.background='#2563eb';}c.appendChild(t);setTimeout(function(){try{t.remove();}catch(e){}},3500);}catch(e){} } try{ window.alert = function(m){ try{ __fb_notify(String(m),'info'); }catch(e){} }; }catch(e){} } )();\n";
          script +=
            "function getVal(sel){try{var el=document.querySelector(sel);if(!el) return ''; if(el.type==='checkbox') return el.checked; return el.value||el.textContent||'';}catch(e){return ''}}\n";
          script +=
            "function submitFor(method,selector){try{var btn=document.querySelector(selector); if(!btn) return; btn.addEventListener('click', function(e){e.preventDefault(); var formData={}; for(var k in mappings){ try{ var s=mappings[k]; var v=getVal(s); formData[k]=v;}catch(e){} } if(method==='GET'||method==='DELETE'){ var qs=Object.keys(formData).map(function(k){return encodeURIComponent(k)+'='+encodeURIComponent(formData[k]);}).join('&'); var url='/api/sites/'+encodeURIComponent(site)+'/endpoints/'+encodeURIComponent(apiName)+'/execute'+(qs?('?'+qs):''); fetch(url,{method:method}).catch(function(e){console.error(e)}); } else { fetch('/api/sites/'+encodeURIComponent(site)+'/endpoints/'+encodeURIComponent(apiName)+'/execute', { method: method, headers: {'Content-Type':'application/json'}, body: JSON.stringify(formData) }).catch(function(e){console.error(e)}); } }); }catch(e){console.error(e)}}\n";
          script +=
            "for(var m in methods){ if(methods[m]) submitFor(m, methods[m]); }\n";
          script += "})();\n";
          return script;
        } catch (e) {
          return "// Error assembling injection script: " + (e && e.message);
        }
      }

      async function injectMappings() {
        try {
          const injectBtn = document.querySelector(
            'button[onclick="injectMappings()"]'
          );
          if (injectBtn) injectBtn.disabled = true;
          const code = assembleInjectionScript();
          const status = document.getElementById("injectStatus");
          const loaderToast = showToast("Injecting mappings...", "loading");
          try {
            const injected = await injectIntoParentEditor(code);
            dismissToast(loaderToast);
            if (injected) {
              showToast("Mappings injected into editor.", "success");
              if (status) status.textContent = "Mappings injected into editor.";
            } else {
              await navigator.clipboard.writeText(code);
              showToast(
                "Editor not detected  code copied to clipboard.",
                "info"
              );
              if (status)
                status.textContent =
                  "Could not inject into editor  code copied to clipboard.";
            }
          } catch (innerErr) {
            dismissToast(loaderToast);
            console.error("injectMappings inner error", innerErr);
            showToast("Error injecting mappings. See console.", "error");
            if (status)
              status.textContent = `Injection error: ${innerErr && innerErr.message}`;
          } finally {
            if (injectBtn) injectBtn.disabled = false;
          }
        } catch (e) {
          console.error("injectMappings error", e);
          showToast("Error injecting mappings: " + (e && e.message), "error");
        }
      }

      function getElementSelector(element) {
        try {
          if (element.id) return "#" + element.id;
          if (element.name)
            return `[name="${element.name.replace(/"/g, '\\"')}"]`;
          if (element.className && typeof element.className === "string") {
            const className = element.className.split(" ")[0];
            if (className) return "." + className;
          }

          // If element has no id/name/class, assign a generated id to make selector stable
          if (!element.id) {
            element.id = `abgen_${Date.now().toString(36)}_${Math.floor(Math.random() * 10000)}`;
            return "#" + element.id;
          }

          // Create a fallback selector
          let selector = element.tagName.toLowerCase();
          if (element.type) selector += `[type="${element.type}"]`;
          return selector;
        } catch (e) {
          console.error("Error creating element selector:", e);
          return "[data-invalid-selector]";
        }
      }

      function updateMappingPreview() {
        const preview = document.getElementById("mappingPreview");
        preview.innerHTML = "<h4>Mappings:</h4>";

        Object.keys(mappings).forEach((field) => {
          const mapping = mappings[field];
          const div = document.createElement("div");
          div.className = "mapping-preview";
          div.innerHTML = `
                    <strong>${field}</strong>  ${mapping.selector}<br>
                    <small>Current value: "${mapping.element.value || "(empty)"}"</small>
                `;
          preview.appendChild(div);
        });
        // Show method -> button mappings
        if (connections && connections.methods) {
          const mkeys = Object.keys(connections.methods);
          if (mkeys.length) {
            const hdr = document.createElement("div");
            hdr.style.marginTop = "8px";
            hdr.innerHTML = "<h4>Method Bindings:</h4>";
            preview.appendChild(hdr);
            mkeys.forEach((m) => {
              const mobj = connections.methods[m];
              const div = document.createElement("div");
              div.className = "mapping-preview";
              div.innerHTML = `<strong>${m}</strong>  ${mobj.selector}`;
              preview.appendChild(div);
            });
          }
        }
      }

      function updateSubmitButtons() {
        const container = document.getElementById("submitButtons");
        container.innerHTML = "";
        const submitElements = formCanvas.querySelectorAll(
          'input[type="submit"], button[type="submit"], button:not([type]), input[type="button"], button[type="button"]'
        );

        // Provide a short instruction in the right panel
        const hint = document.createElement("div");
        hint.style.color = "var(--muted)";
        hint.style.fontSize = "13px";
        hint.style.marginBottom = "8px";
        hint.textContent =
          "Click a submit button inside the form to select it for injection.";
        container.appendChild(hint);

        submitElements.forEach((btn, index) => {
          const div = document.createElement("div");
          div.className = "submit-button-option";
          div.dataset.index = index;
          div.textContent = `${btn.tagName}${btn.type ? `[${btn.type}]` : ""}: "${btn.value || btn.textContent || "Submit"}`;

          // Highlight the list entry if this button is selected
          if (
            selectedSubmitButton &&
            (selectedSubmitButton === btn ||
              selectedSubmitButton.isSameNode(btn))
          ) {
            div.classList.add("selected");
          }

          // clicking the list entry will also select the actual button in the canvas
          div.onclick = () => selectSubmitButton(btn, div);
          container.appendChild(div);
        });

        // mark submit candidates inside canvas (visual affordance)
        markSubmitCandidates();
      }

      function selectSubmitButton(button, element) {
        // set variable
        selectedSubmitButton = button;

        // update right-side list
        document
          .querySelectorAll(".submit-button-option")
          .forEach((el) => el.classList.remove("selected"));
        if (element) element.classList.add("selected");

        // update in-canvas visual selection
        const submitElements = formCanvas.querySelectorAll(
          'input[type="submit"], button[type="submit"], button:not([type]), input[type="button"], button[type="button"]'
        );
        submitElements.forEach((b) => b.classList.remove("selected"));
        try {
          button.classList.add("selected");
        } catch (e) {}
      }

      function markSubmitCandidates() {
        const els = formCanvas.querySelectorAll(
          'input[type="submit"], button[type="submit"], button:not([type]), input[type="button"], button[type="button"]'
        );
        els.forEach((el, idx) => {
          // attach selectable class and a click handler to choose this as the submit target
          el.classList.add("selectable-submit");
          // avoid duplicate handlers
          if (!el._fbClick) {
            el._fbClick = function (e) {
              e.preventDefault();
              selectSubmitButton(el);
              updateSubmitButtons();
            };
            el.addEventListener("click", el._fbClick);
          }
        });
      }

      function loadFormFromClipboard() {
        navigator.clipboard
          .readText()
          .then((text) => {
            formCanvas.innerHTML = text;
            formCanvas.classList.remove("full-page");
            updateSubmitButtons();
            attachFormEvents();
          })
          .catch((err) => {
            console.error("Error reading clipboard:", err);
            alert("Could not read clipboard. Please paste HTML directly.");
          });
      }

      function clearForm() {
        formCanvas.innerHTML =
          '<p style="color: #7f8c8d; text-align: center; margin-top: 180px;">Paste your HTML form code here or drag form elements</p>';
        formCanvas.classList.remove("full-page");
        mappings = {};
        selectedSubmitButton = null;
        updateMappingPreview();
        updateSubmitButtons();
      }

      function attachFormEvents() {
        // Re-attach drag events to new form elements
        formCanvas.addEventListener("dragover", function (e) {
          e.preventDefault();
        });
      }

      function generateCode() {
        try {
          if (!selectedSubmitButton) {
            alert("Please select a submit button first.");
            return;
          }

          if (Object.keys(mappings).length === 0) {
            alert("Please create at least one mapping first.");
            return;
          }

          if (!currentAPI) {
            alert("No API loaded. Please reload the form builder.");
            return;
          }

          const code = generateSubmissionScript();
          const genEl = document.getElementById("generatedCode");
          const codeOut = document.getElementById("codeOutput");
          if (genEl) genEl.textContent = code;
          if (codeOut) codeOut.style.display = "block";

          // Try to inject code into parent editor, otherwise copy to clipboard.
          const status = document.getElementById("injectStatus");
          (async () => {
            try {
              if (
                window.parent &&
                typeof window.parent.insertCodeAtCursor === "function"
              ) {
                window.parent.insertCodeAtCursor(code);
                status.textContent = "Code injected into the editor.";
              } else {
                await navigator.clipboard.writeText(code);
                status.textContent =
                  "Editor not detected  code copied to clipboard.";
              }

              // Enable the preview button after injection/copy
              const previewBtn = document.getElementById("openPreviewBtn");
              if (previewBtn) previewBtn.disabled = false;
            } catch (e) {
              console.error("Error injecting or copying code:", e);
              status.textContent = `Could not inject or copy code: ${e.message}`;
            }
          })();

          // Also save the action to track page-API relationship
          saveActionForPage();
        } catch (e) {
          console.error("Error in generateCode:", e);
          alert(`Error generating code: ${e.message}`);
        }
      }

      function saveActionForPage() {
        if (!selectedSubmitButton || !currentAPI) {
          console.warn("Cannot save action: missing submit button or API");
          return;
        }

        if (!validateSiteContext()) return;

        // Ensure we have a current page set
        if (!window.currentPage) {
          console.warn("No current page set, cannot save page mappings");
          alert("Please select a page first before generating code.");
          return;
        }

        const submitSelector = getElementSelector(selectedSubmitButton);
        const fields = Object.keys(mappings);

        // Save action for runtime execution
        fetch(
          `/api/sites/${encodeURIComponent(window.currentSiteName)}/actions`,
          {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({
              selector: submitSelector,
              apiName: currentAPI.name,
              method: currentAPI.method,
              fields: fields,
              page: window.currentPage,
            }),
          }
        )
          .then((response) => {
            if (!response.ok) {
              throw new Error(
                `HTTP ${response.status}: ${response.statusText}`
              );
            }
            return response.json();
          })
          .then((action) => {
            console.log("Action saved:", action);

            // Also save/update page mapping for form builder persistence
            const fieldMappings = {};
            Object.keys(mappings).forEach((field) => {
              fieldMappings[field] = mappings[field].selector;
            });

            return fetch(
              `/api/sites/${encodeURIComponent(window.currentSiteName)}/page-mappings`,
              {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({
                  page: window.currentPage,
                  apiName: currentAPI.name,
                  method: currentAPI.method,
                  fieldMappings: fieldMappings,
                  submitSelector: submitSelector,
                }),
              }
            );
          })
          .then((response) => {
            if (!response.ok) {
              throw new Error(
                `HTTP ${response.status}: ${response.statusText}`
              );
            }
            return response.json();
          })
          .then((mapping) => {
            console.log("Page mapping saved:", mapping);
            // Refresh the pages list to show the new relationship
            loadPagesForAPI();
          })
          .catch((error) => {
            console.error("Error saving mappings:", error);
            alert(`Error saving mappings: ${error.message}`);
          });
      }

      function generateSubmissionScript() {
        try {
          const submitSelector = getElementSelector(selectedSubmitButton);
          const apiName = currentAPI.name;
          const method = (currentAPI.method || "POST").toUpperCase();
          const siteEncoded = encodeURIComponent(getCurrentSite());

          let code = `// Form submission code for ${method} ${apiName}\n`;
          code += `document.querySelector('${submitSelector.replace(/'/g, "\\'")}').addEventListener('click', function(e) {\n`;
          code += `  e.preventDefault();\n`;
          // inline notification helper for injected code (top-right toasts)
          code += `  function __fb_notify(msg,type){try{var c=document.getElementById('__fb_toast_container');if(!c){c=document.createElement('div');c.id='__fb_toast_container';c.style.position='fixed';c.style.top='16px';c.style.right='16px';c.style.zIndex='9999999';c.style.display='flex';c.style.flexDirection='column';c.style.gap='8px';document.body.appendChild(c);}var t=document.createElement('div');t.textContent=msg;t.style.padding='8px 12px';t.style.borderRadius='8px';t.style.color='#fff';t.style.fontFamily='sans-serif';t.style.fontSize='13px';t.style.boxShadow='0 8px 24px rgba(0,0,0,0.18)';if(type==='success'){t.style.background='#16a34a';}else if(type==='error'){t.style.background='#ef4444';}else{t.style.background='#2563eb';}c.appendChild(t);setTimeout(function(){try{t.remove();}catch(e){}},3500);}catch(e){} }\n`;
          code += `  var formData = {};\n`;

          Object.keys(mappings).forEach((field) => {
            const selector = mappings[field].selector;
            const element = mappings[field].element;
            const inputType = element.type;

            if (inputType === "checkbox") {
              code += `  formData.${field} = document.querySelector('${selector.replace(/'/g, "\\'")}').checked;\n`;
            } else {
              code += `  formData.${field} = document.querySelector('${selector.replace(/'/g, "\\'")}').value;\n`;
            }
          });

          // Build request depending on method
          if (method === "GET" || method === "DELETE") {
            code += `  // Build query string for ${method}\n`;
            code += `  const qs = Object.keys(formData).map(k=>encodeURIComponent(k)+'='+encodeURIComponent(formData[k])).join('&');\n`;
            code += `  const url = '/api/sites/${siteEncoded}/endpoints/${encodeURIComponent(apiName)}/execute' + (qs ? ('?' + qs) : '');\n`;
            code += `  fetch(url, { method: '${method}' })\n`;
          } else {
            code += `  // Submit as JSON body\n`;
            code += `  fetch('/api/sites/${siteEncoded}/endpoints/${encodeURIComponent(apiName)}/execute', {\n`;
            code += `    method: '${method}',\n`;
            code += `    headers: { 'Content-Type': 'application/json' },\n`;
            code += `    body: JSON.stringify(formData)\n`;
            code += `  })\n`;
          }

          code += `  .then(response => response.json())\n`;
          code += `  .then(data => {\n`;
          code += `    console.log('Success:', data);\n`;
          code += `    try{ __fb_notify('Form submitted successfully!','success'); }catch(e){ }\n`;
          code += `  })\n`;
          code += `  .catch(error => {\n`;
          code += `    console.error('Error:', error);\n`;
          code += `    try{ __fb_notify('Error submitting form','error'); }catch(e){}\n`;
          code += `  });\n`;
          code += `});\n`;

          return code;
        } catch (e) {
          console.error("Error generating submission script:", e);
          return `// Error generating code: ${e.message}\nconsole.error('Code generation failed');`;
        }
      }

      function getCurrentSite() {
        if (!window.currentSiteName) {
          console.error("getCurrentSite called but currentSiteName is not set");
          return "demo"; // fallback
        }
        return window.currentSiteName;
      }

      // Try multiple strategies to inject code into a parent editor.
      // Returns true if injection succeeded, false otherwise.
      async function injectIntoParentEditor(code) {
        try {
          // 1) Preferred API - parent exposes an insert function
          if (
            window.parent &&
            typeof window.parent.insertCodeAtCursor === "function"
          ) {
            try {
              window.parent.insertCodeAtCursor(code);
              return true;
            } catch (e) {
              console.warn("parent.insertCodeAtCursor failed:", e);
            }
          }

          // 2) Try to find a textarea or editor element in parent and append before </html>
          if (window.parent && window.parent.document) {
            const pdoc = window.parent.document;
            // common editor selectors
            const selectorCandidates = [
              "textarea.editor",
              "textarea#editor",
              'textarea[name="editor"]',
              "textarea",
              'input[type="text"][id*="editor"]',
              '[contenteditable="true"]',
              "[contenteditable]",
            ];

            for (const sel of selectorCandidates) {
              const el = pdoc.querySelector(sel);
              if (el) {
                // If it's a textarea/input use value, else use innerHTML
                const scriptTag =
                  '\n<script type="text/javascript">\n' +
                  code +
                  "\n<\/script>\n";
                if (el.tagName === "TEXTAREA" || el.tagName === "INPUT") {
                  let val = el.value || "";
                  const lower = val.toLowerCase();
                  const idx = lower.lastIndexOf("</html>");
                  if (idx !== -1) {
                    val = val.slice(0, idx) + scriptTag + val.slice(idx);
                  } else {
                    val = val + scriptTag;
                  }
                  el.value = val;
                  el.dispatchEvent(new Event("input", { bubbles: true }));
                  return true;
                } else {
                  // contenteditable or other element
                  try {
                    // If the element contains a full HTML string
                    let html = el.innerHTML || "";
                    const lower = html.toLowerCase();
                    const idx = lower.lastIndexOf("</html>");
                    if (idx !== -1) {
                      html = html.slice(0, idx) + scriptTag + html.slice(idx);
                      el.innerHTML = html;
                    } else {
                      // append a script element directly to parent body
                      const s = pdoc.createElement("script");
                      s.type = "text/javascript";
                      s.textContent = code;
                      pdoc.body.appendChild(s);
                    }
                    return true;
                  } catch (e) {
                    console.warn("failed to inject into contenteditable", e);
                  }
                }
              }
            }

            // 3) As a last resort append a script node to parent document body (same-origin only)
            try {
              const s = pdoc.createElement("script");
              s.type = "text/javascript";
              s.textContent = code;
              pdoc.body.appendChild(s);
              return true;
            } catch (e) {
              console.warn("append script to parent body failed", e);
            }
          }

          return false;
        } catch (e) {
          console.error("injectIntoParentEditor error", e);
          return false;
        }
      }

      function copyCode() {
        // preserved for compatibility but not used in new flow
        alert("Code view removed. Use Inject Mappings to inject wiring.");
      }

      function closeCodeOutput() {
        // no-op (code output removed)
      }

      // Global drag events (removed - using connector mode instead)

      // Preview helper (global) for opening a full preview in a new tab
      window.openPreviewTab = function (pageName) {
        if (!pageName) pageName = window.currentPage || "";
        if (!validateSiteContext()) return;
        if (!pageName) {
          alert("Please select a page to open");
          return;
        }
        const url = `/site/${encodeURIComponent(window.currentSiteName)}/${pageName}?t=${Date.now()}`;
        window.open(url, "_blank");
      };
    </script>
  </body>
</html>
